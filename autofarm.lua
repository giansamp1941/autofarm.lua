gg.setRanges(gg.REGION_ANONYMOUS | gg.REGION_C_ALLOC)
gg.clearResults()

--[[
  SCRIPT DE RIO RISE V2 SAFE
  Desenvolvido por: GIAN HENRIQUE
  Desenvolvido por: Plinio
  Vers√£o: V0.5 SAFE MOD + SUBTERR√ÇNEO + DELAY PERSONALIZADO
]]

-- Configura√ß√µes globais
local enderecoBase = nil
local offsets = {Y = 0x60, X = 0x64, Z = 0x68}
local posicoesSalvas = {}
local posicoesFarm = {}
local scriptAtivo = true
local caminhando = false
local velocidadeCaminhar = 50
local velocidadeCarregar = 50
local delayAutoFarm = 5
local movimentoTipo = "padrao" -- Op√ß√µes: "padrao", "subterraneo", "aereo", "invisivel"
local versao = "V0.5 SAFE MOD + AUTOM√ÅTICO"
local maxPosicoesSalvas = 50 -- Aumentado de 10 para 50

-- Configura√ß√µes subterr√¢neo
local alturaSubterraneo = -10.0 -- Altura padr√£o abaixo do ch√£o
local tempoSubida = 1000 -- Tempo em milissegundos para subir/descer
local tempoCheckpoint = 2000 -- Tempo em milissegundos no checkpoint

-- Nome dos arquivos
local ARQUIVO_POSICOES = "gh_samp_posicoes_v3.dat"
local ARQUIVO_FARM = "gh_samp_farm_v3.dat"

-- Locais estrat√©gicos
local RIO_RISE_SPOTS = {
    ["üè° Fazenda"] = {x = 80.74, y = -49.74, z = 3.12},
    ["‚õèÔ∏è Mina"] = {x = -1560.35, y = -97.57, z = 63.46},
    ["üî´ LOB Inicial"] = {x = -2655.95, y = -956.31, z = 32.81},
    ["üçî Lanchonete"] = {x = -2603.21, y = -968.39, z = 32.85},
    ["üëï Loja de Roupa"] = {x = -2613.60, y = -1015.26, z = 32.85},
    ["üè™ Loja 24/7"] = {x = -2622.08, y = -1056.59, z = 32.85},
    ["üè¶ Banco"] = {x = -2551.22, y = -1205.51, z = 33.34},
    ["üöó Auto Escola"] = {x = -2562.07, y = -1281.41, z = 33.55},
    ["üèõÔ∏è Prefeitura"] = {x = -1848.71, y = 620.66, z = 3.95},
    ["üè• HP"] = {x = -1918.17, y = 871.51, z = 2.57},
    ["üëÆ DP CV"] = {x = -1411.63, y = 652.67, z = 1.64},
    ["üî® Leil√£o"] = {x = -1460.09, y = 707.97, z = 3.04}
}

-- Fun√ß√£o para configurar movimento subterr√¢neo
function configurarSubterraneo()
    local configs = gg.prompt({
        "Altura abaixo do ch√£o (negativo):",
        "Tempo para subir/descer (ms):",
        "Tempo no checkpoint (ms):"
    }, {tostring(alturaSubterraneo), tostring(tempoSubida), tostring(tempoCheckpoint)}, {"number", "number", "number"})
    
    if configs then
        alturaSubterraneo = tonumber(configs[1]) or alturaSubterraneo
        tempoSubida = tonumber(configs[2]) or tempoSubida
        tempoCheckpoint = tonumber(configs[3]) or tempoCheckpoint
        gg.toast(string.format("‚öôÔ∏è Config subterr√¢neo: Altura %.1f, Tempos %d/%dms", alturaSubterraneo, tempoSubida, tempoCheckpoint))
    end
end

-- Fun√ß√£o para movimento subterr√¢neo
function moverSubterraneo(x, y, z)
    local posAtual = obterCoordenadas()
    
    -- Descer para altura subterr√¢nea
    local passosDescida = 10
    for i = 1, passosDescida do
        local progresso = i / passosDescida
        local novoZ = posAtual.z + (alturaSubterraneo - posAtual.z) * progresso
        definirCoordenadas(posAtual.x, posAtual.y, novoZ)
        gg.sleep(tempoSubida / passosDescida)
    end
    
    -- Mover para posi√ß√£o X/Y subterr√¢nea
    local distanciaXY = math.sqrt((x - posAtual.x)^2 + (y - posAtual.y)^2)
    local passosMovimento = math.max(5, math.floor(distanciaXY / 10))
    
    for i = 1, passosMovimento do
        local progresso = i / passosMovimento
        local novoX = posAtual.x + (x - posAtual.x) * progresso
        local novoY = posAtual.y + (y - posAtual.y) * progresso
        definirCoordenadas(novoX, novoY, alturaSubterraneo)
        gg.sleep(50)
    end
    
    -- Subir para pegar checkpoint
    local passosSubida = 10
    for i = 1, passosSubida do
        local progresso = i / passosSubida
        local novoZ = alturaSubterraneo + (z - alturaSubterraneo) * progresso
        definirCoordenadas(x, y, novoZ)
        gg.sleep(tempoSubida / passosSubida)
    end
    
    -- Manter no checkpoint por um tempo
    definirCoordenadas(x, y, z)
    gg.sleep(tempoCheckpoint)
    
    -- Descer novamente
    for i = 1, passosDescida do
        local progresso = i / passosDescida
        local novoZ = z + (alturaSubterraneo - z) * progresso
        definirCoordenadas(x, y, novoZ)
        gg.sleep(tempoSubida / passosDescida)
    end
end

-- Fun√ß√£o para salvar arquivo
function salvarArquivo(nomeArquivo, conteudo)
    local arquivo = io.open(nomeArquivo, "w")
    if arquivo then
        arquivo:write(conteudo)
        arquivo:close()
        return true
    end
    return false
end

-- Fun√ß√£o para carregar arquivo
function carregarArquivo(nomeArquivo)
    local arquivo = io.open(nomeArquivo, "r")
    if arquivo then
        local conteudo = arquivo:read("*a")
        arquivo:close()
        return conteudo
    end
    return nil
end

-- Fun√ß√£o para mostrar cabe√ßalho
function mostrarCabecalho()
    gg.clearResults()
    gg.toast("üîπ GIAN SAMP - RIO RISE "..versao.." üîπ", false)
    print("‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ")
    print("‚ñà GIAN SAMP - RIO RISE "..versao.." ‚ñà")
    print("‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ")
end

-- Fun√ß√£o para salvar posi√ß√£o atual
function salvarPosicaoAtual(nomePadrao)
    local pos = obterCoordenadas()
    local nome = gg.prompt({"Digite um nome para esta posi√ß√£o:"}, {nomePadrao}, {"text"})
    
    if nome and nome[1] then
        if #posicoesSalvas >= maxPosicoesSalvas then
            table.remove(posicoesSalvas, 1)
        end
        
        table.insert(posicoesSalvas, {
            nome = nome[1],
            x = pos.x,
            y = pos.y,
            z = pos.z,
            delay = 5 -- Delay padr√£o de 5 segundos
        })
        
        salvarPosicoesNoArmazenamento()
        gg.toast("‚úÖ Posi√ß√£o salva: "..nome[1].." ("..#posicoesSalvas.."/"..maxPosicoesSalvas..")")
    end
end

-- Fun√ß√£o para editar delay de uma posi√ß√£o
function editarDelayPosicao()
    if #posicoesSalvas == 0 then
        gg.toast("üö´ Nenhuma posi√ß√£o salva dispon√≠vel!")
        return
    end

    local opcoes = {}
    for i, pos in ipairs(posicoesSalvas) do
        table.insert(opcoes, pos.nome .. " (Delay: " .. (pos.delay or 500) .. "ms)")
    end

    local escolha = gg.choice(opcoes, nil, "‚è±Ô∏è Escolha a posi√ß√£o para editar delay:")
    if not escolha then return end

    local entrada = gg.prompt({
        "Digite o valor do delay:",
        "Escolha a unidade (ms, s, min):"
    }, {
        tostring(posicoesSalvas[escolha].delay or 500),
        "ms"
    }, {
        "number", "text"
    })

    if entrada then
        local valor = tonumber(entrada[1]) or 500
        local unidade = entrada[2]:lower()

        local multiplicador = 1
        if unidade == "s" or unidade == "seg" or unidade == "segundo" or unidade == "segundos" then
            multiplicador = 1000
        elseif unidade == "min" or unidade == "minuto" or unidade == "minutos" then
            multiplicador = 60000
        end

        local delayFinal = math.max(50, valor * multiplicador)
        posicoesSalvas[escolha].delay = delayFinal
        salvarPosicoesNoArmazenamento()
        gg.toast("‚è±Ô∏è Delay atualizado para " .. delayFinal .. "ms!")
    end
end


-- Fun√ß√µes de salvamento/carregamento
function salvarPosicoesNoArmazenamento()
    local dados = {}
    for i, pos in ipairs(posicoesSalvas) do
        table.insert(dados, string.format("%s|%.2f|%.2f|%.2f|%d", pos.nome, pos.x, pos.y, pos.z, pos.delay or 5))
    end
    if salvarArquivo(ARQUIVO_POSICOES, table.concat(dados, "\n")) then
        gg.toast("‚úÖ Posi√ß√µes salvas com sucesso!")
    else
        gg.toast("Erro ao salvar posi√ß√µes!")
    end
end

function carregarPosicoesDoArmazenamento()
    local dados = carregarArquivo(ARQUIVO_POSICOES)
    if dados then
        posicoesSalvas = {}
        for linha in dados:gmatch("[^\n]+") do
            local partes = {}
            for parte in linha:gmatch("([^|]+)") do
                table.insert(partes, parte)
            end
            
            if #partes >= 4 then
                local posicao = {
                    nome = partes[1],
                    x = tonumber(partes[2]),
                    y = tonumber(partes[3]),
                    z = tonumber(partes[4]),
                    delay = tonumber(partes[5]) or 5 -- Default para 5s se n√£o existir
                }
                table.insert(posicoesSalvas, posicao)
            end
        end
        gg.toast(string.format("üìÇ %d posi√ß√µes carregadas!", #posicoesSalvas))
    else
        gg.toast("Nenhuma posi√ß√£o salva encontrada!")
    end
end

-- Fun√ß√£o para salvar posi√ß√µes de farm
function salvarPosicoesFarm()
    if #posicoesSalvas < 2 then
        gg.toast("üö´ Salve pelo menos 2 posi√ß√µes antes de configurar o auto farm!")
        return
    end

    local opcoes = {}
    for i, pos in ipairs(posicoesSalvas) do
        table.insert(opcoes, pos.nome .. " (X:" .. math.floor(pos.x) .. " Y:" .. math.floor(pos.y) .. ")")
    end

    local escolhas = gg.multiChoice(opcoes, nil, "‚úÖ Selecione as posi√ß√µes para o Auto Farm (sem limite):")
    if not escolhas then return end

    posicoesFarm = {} -- limpa as anteriores

    for i = 1, #posicoesSalvas do
        if escolhas[i] then
            table.insert(posicoesFarm, posicoesSalvas[i])
        end
    end

    local dados = ""
    for i, pos in ipairs(posicoesFarm) do
        dados = dados .. string.format("%s|%.2f|%.2f|%.2f|%d\n", pos.nome, pos.x, pos.y, pos.z, pos.delay or 500)
    end

    if salvarArquivo(ARQUIVO_FARM, dados) then
        gg.toast("‚úÖ Posi√ß√µes de farm salvas com sucesso!")
    else
        gg.toast("‚ùå Erro ao salvar posi√ß√µes de farm!")
    end
end

-- Fun√ß√£o para carregar posi√ß√µes de farm
function carregarPosicoesFarm()
    local dados = carregarArquivo(ARQUIVO_FARM)
    if dados then
        posicoesFarm = {}
        for linha in dados:gmatch("[^\n]+") do
            local partes = {}
            for parte in linha:gmatch("([^|]+)") do
                table.insert(partes, parte)
            end
            
            if #partes >= 4 then
                local posicao = {
                    nome = partes[1],
                    x = tonumber(partes[2]),
                    y = tonumber(partes[3]),
                    z = tonumber(partes[4]),
                    delay = tonumber(partes[5]) or 5
                }
                table.insert(posicoesFarm, posicao)
            end
        end
        gg.toast(string.format("üìÇ %d posi√ß√µes de farm carregadas!", #posicoesFarm))
    else
        gg.toast("Nenhuma posi√ß√£o de farm salva encontrada!")
    end
end

-- Fun√ß√£o para obter coordenadas
function obterCoordenadas()
    if not enderecoBase then inicializar() end
    
    local valores = gg.getValues({
        {address = enderecoBase + offsets.Y, flags = gg.TYPE_FLOAT},
        {address = enderecoBase + offsets.X, flags = gg.TYPE_FLOAT},
        {address = enderecoBase + offsets.Z, flags = gg.TYPE_FLOAT}
    })

    return {
        y = valores[1].value,
        x = valores[2].value,
        z = valores[3].value
    }
end

-- Fun√ß√£o para definir coordenadas
function definirCoordenadas(x, y, z)
    if not enderecoBase then inicializar() end
    
    gg.setValues({
        {address = enderecoBase + offsets.X, flags = gg.TYPE_FLOAT, value = x},
        {address = enderecoBase + offsets.Y, flags = gg.TYPE_FLOAT, value = y},
        {address = enderecoBase + offsets.Z, flags = gg.TYPE_FLOAT, value = z}
    })
end

-- Fun√ß√£o para caminhar com seguran√ßa
function caminharAtePosicao(x, y, z, tipoMovimento)
    local posAtual = obterCoordenadas()
    
    -- Salvamento silencioso (SEM TOAST)
    if #posicoesSalvas >= maxPosicoesSalvas then
        table.remove(posicoesSalvas, 1)
    end
    table.insert(posicoesSalvas, {
        nome = "Backup "..os.date("%H:%M:%S"),
        x = posAtual.x,
        y = posAtual.y,
        z = posAtual.z,
        delay = 5
    })
    
    if caminhando then
        gg.toast("‚ö†Ô∏è J√° est√° caminhando para uma posi√ß√£o!")
        return
    end
    
    caminhando = true
    
    if tipoMovimento == "subterraneo" then
        moverSubterraneo(x, y, z)
    else
    definirCoordenadas(x, y, z)
    gg.toast("‚ö° Teleporte r√°pido para destino!")
end
    
    caminhando = false
end

-- Fun√ß√£o para caminhar para posi√ß√£o salva
function caminharParaPosicaoSalva()
    if #posicoesSalvas == 0 then
        gg.toast("üö´ Nenhuma posi√ß√£o salva dispon√≠vel!")
        return
    end
    
    local opcoes = {}
    for i, pos in ipairs(posicoesSalvas) do
        table.insert(opcoes, pos.nome .. " (X:" .. math.floor(pos.x) .. " Y:" .. math.floor(pos.y) .. ")")
    end
    
    local escolha = gg.choice(opcoes, nil, "üßº Escolha a posi√ß√£o para caminhar:")
    if not escolha then
        return
    end
    
    local posicao = posicoesSalvas[escolha]
    caminharAtePosicao(posicao.x, posicao.y, posicao.z, movimentoTipo)
end

-- Fun√ß√£o para ajustar velocidade de carregamento
function ajustarVelocidadeCarregar()
    local novaVelocidade = gg.prompt({"Digite a velocidade de carregamento (1-100):"}, {tostring(velocidadeCarregar)}, {"number"})
    if novaVelocidade and tonumber(novaVelocidade[1]) then
        velocidadeCarregar = math.max(1, math.min(100, tonumber(novaVelocidade[1])))
        gg.toast("‚ö° Velocidade de carregamento ajustada: " .. velocidadeCarregar .. "!")
    end
end

-- Fun√ß√£o para ajustar delay do auto farm
function ajustarDelayAutoFarm()
    local novoDelay = gg.prompt({"Digite o delay entre as posi√ß√µes (segundos):"}, {tostring(delayAutoFarm)}, {"number"})
    if novoDelay and tonumber(novoDelay[1]) then
        delayAutoFarm = math.max(1, tonumber(novoDelay[1]))
        gg.toast("‚è≥ Delay do auto farm ajustado: " .. delayAutoFarm .. " segundos!")
    end
end

-- Fun√ß√£o para configurar velocidade de teleporte
function configurarVelocidadeTeleporte()
    local novaVelocidade = gg.prompt({
        "Velocidade do teleporte (1-100):\n(1 = mais lento/suave, 100 = mais r√°pido)"},
        {tostring(velocidadeCarregar)},
        {"number"})
    
    if novaVelocidade and tonumber(novaVelocidade[1]) then
        velocidadeCarregar = math.max(1, math.min(100, tonumber(novaVelocidade[1])))
        gg.toast("‚ö° Velocidade do teleporte: "..velocidadeCarregar)
    end
end

-- Fun√ß√£o para o auto farm
function autoFarm()
    if #posicoesFarm == 0 then
        gg.toast("üö´ Nenhuma posi√ß√£o de farm configurada!")
        return
    end

    local executando = true
local ciclos = 0
local reverso = false

gg.alert("üîÅ Auto Farm iniciado!\n\nToque no bot√£o flutuante do GG para PARAR.")

while executando do
    -- Define a ordem das posi√ß√µes (normal ou reversa)
    local lista = reverso and {} or posicoesFarm

    if reverso and modoReversoAtivado then
        -- Copia posicoesFarm de tr√°s pra frente
        for i = #posicoesFarm, 1, -1 do
            table.insert(lista, posicoesFarm[i])
        end
    end

    for _, posicao in ipairs(lista) do
        if not executando then break end

        local posAtual = obterCoordenadas()
        if #posicoesSalvas >= maxPosicoesSalvas then
            table.remove(posicoesSalvas, 1)
        end
        table.insert(posicoesSalvas, {
            nome = "Farm "..os.date("%H:%M:%S"),
            x = posAtual.x,
            y = posAtual.y,
            z = posAtual.z,
            delay = 500
        })

        caminharAtePosicao(posicao.x, posicao.y, posicao.z, movimentoTipo)

        local delayAtual = posicao.delay or (delayAutoFarm * 1000)
local tempoPassado = 0
local paradoPor = 0
local intervalo = 250 -- checagem a cada 250ms
local posAnterior = obterCoordenadas()

gg.toast("üéÆ AUTO FARM BY: GIAN SAMP.  POSI√á√ÉO:" .. posicao.nome)

local tentativasTravadas = 0
local maxTravadas = 2
local delayEntreTentativas = 1500 -- 1.5s extra de espera se travar

while tempoPassado < delayAtual do
    gg.sleep(intervalo)
    tempoPassado = tempoPassado + intervalo

    local posAtual = obterCoordenadas()
    local dx = math.abs(posAtual.x - posAnterior.x)
    local dy = math.abs(posAtual.y - posAnterior.y)
    local dz = math.abs(posAtual.z - posAnterior.z)

    if dx < 0.05 and dy < 0.05 and dz < 0.05 then
        paradoPor = paradoPor + intervalo
        if paradoPor >= 1800 then
            tentativasTravadas = tentativasTravadas + 1
            gg.toast("‚ö†Ô∏è Parado "..tentativasTravadas.."x. Esperando antes de tentar pular...")

            if tentativasTravadas >= maxTravadas then
                gg.sleep(delayEntreTentativas)
                gg.toast("‚ö†Ô∏è Travado v√°rias vezes! Indo para pr√≥xima posi√ß√£o...")
                goto proximaPosicao
            end

            paradoPor = 0
        end
    else
        paradoPor = 0
        tentativasTravadas = 0
    end

    posAnterior = posAtual
end

        if gg.isVisible(true) then
            gg.setVisible(false)
            local confirm = gg.alert("‚ùì Deseja PARAR o Auto Farm?", "Sim", "N√£o")
            if confirm == 1 then
                executando = false
                break
            end
        end
   ::proximaPosicao::
    end

    if executando then
        ciclos = ciclos + 1
        gg.toast("‚úÖ Ciclo " .. ciclos .. " completo!")
        -- Alterna modo reverso se ativado
        if modoReversoAtivado then
            reverso = not reverso
        end
    end
end

    gg.toast("üõë Auto Farm finalizado! Total de ciclos: " .. ciclos)
end

-- Fun√ß√£o para teleporte suave
function teleportSeguroV2(x, y, z)
    local posAtual = obterCoordenadas()
    
    if #posicoesSalvas >= maxPosicoesSalvas then
        table.remove(posicoesSalvas, 1)
    end
    table.insert(posicoesSalvas, {
        nome = "Backup TP "..os.date("%H:%M:%S"),
        x = posAtual.x,
        y = posAtual.y,
        z = posAtual.z,
        delay = 5
    })

    definirCoordenadas(x, y, z)
    gg.sleep(100) -- Voc√™ pode remover essa linha se quiser INSTANT√ÇNEO
end

-- Fun√ß√£o para ajustar tipo de movimento
function ajustarTipoMovimento()
    local opcoes = {
        "padr√£o",
        "subterr√¢neo",
        "a√©reo",
        "invis√≠vel",
        "voltar para padr√£o"
    }
    
    local escolha = gg.choice(opcoes, nil, "üß© Escolha o tipo de movimento:")
    if escolha then
        if escolha == 5 then
            movimentoTipo = "padrao"
        else
            movimentoTipo = opcoes[escolha]
        end
        gg.toast("‚úÖ Tipo de movimento ajustado para: "..movimentoTipo.."!")
    end
end

-- Fun√ß√£o para deletar v√°rias posi√ß√µes
function deletarPosicoes()
    if #posicoesSalvas == 0 then
        gg.toast("üö´ Nenhuma posi√ß√£o salva para deletar!")
        return
    end
    
    local opcoes = {}
    for i, pos in ipairs(posicoesSalvas) do
        table.insert(opcoes, pos.nome .. " (X:" .. math.floor(pos.x) .. " Y:" .. math.floor(pos.y) .. ")")
    end
    
    local escolhas = gg.multiChoice(opcoes, nil, "Selecione as posi√ß√µes para deletar:")
    
    if escolhas then
        for i = #escolhas, 1, -1 do
            if escolhas[i] then
                table.remove(posicoesSalvas, i)
            end
        end
        salvarPosicoesNoArmazenamento()
        gg.toast("üóëÔ∏è Posi√ß√µes deletadas com sucesso!")
    end
end

-- Fun√ß√£o para parar caminhada
function pararCaminhada()
    caminhando = false
    gg.toast("üõë Caminhada interrompida!")
end

-- Fun√ß√£o para inicializar
function inicializar()
    if not enderecoBase then
        gg.setVisible(false)
        gg.clearResults()
        
        local function buscarEndereco()
            gg.searchNumber("999.765625", gg.TYPE_FLOAT)
            local results = gg.getResults(1)
            if #results > 0 then return results[1].address end
            
            gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
            gg.searchNumber("999.765625", gg.TYPE_FLOAT)
            results = gg.getResults(1)
            return #results > 0 and results[1].address or nil
        end
        
        enderecoBase = buscarEndereco()
        
        if enderecoBase then
            gg.toast("‚úÖ Base encontrada com sucesso!")
            carregarPosicoesDoArmazenamento()
            carregarPosicoesFarm()
        else
            gg.alert("‚ùå Falha ao encontrar endere√ßo base!\n\nTente reiniciar o jogo.")
            os.exit()
        end
    end
end

-- Menu principal
function menuPrincipal()
    while scriptAtivo do
        if not gg.isVisible() then
            gg.sleep(100)
        else
            gg.setVisible(false)

            local opcoes = {
                "üìç Teleportar para Local",
                "üö∂ Caminhar para Coordenadas",
                "üßº Caminhar para Posi√ß√£o Salva",
                "‚ö° Ajustar Velocidade de Carregamento",
                "‚è≥ Ajustar Delay do Auto Farm",
                "‚öôÔ∏è Ajustar Tipo de Movimento",
                "‚öôÔ∏è Configurar Subterr√¢neo",
                "üíæ Salvar Posi√ß√£o",
                "üìÅ Carregar Posi√ß√£o Salva",
                "‚öôÔ∏è Configurar Auto Farm",
                "AGR Auto Farm",
                "üóëÔ∏è Deletar Posi√ß√£o Salva",
                "üõë Parar Caminhada",
                "‚è±Ô∏è Editar Delay de Posi√ß√£o",
                "‚ö° Configurar Velocidade TP",
                "üîÉ Ativar/Desativar Modo Reverso",
                "‚ùå Sair"
            }
            
            local escolha = gg.choice(opcoes, nil, "GIAN SAMP - RIO RISE\nBy: GIAN HENRIQUE\nVers√£o: "..versao)
            
            if not escolha then 
                gg.toast("üï∂Ô∏è Script minimizado")
            else
                if opcoes[escolha] == "üìç Teleportar para Local" then
                    local locais = {}
                    for nome in pairs(RIO_RISE_SPOTS) do
                        table.insert(locais, nome)
                    end
                    table.sort(locais)
                    
                    local localEscolhido = gg.choice(locais, nil, "Escolha o local:")
                    if localEscolhido then
                        local destino = RIO_RISE_SPOTS[locais[localEscolhido]]
                        teleportSeguroV2(destino.x, destino.y, destino.z)
                    end
                    
                elseif opcoes[escolha] == "üö∂ Caminhar para Coordenadas" then
                    local coords = gg.prompt({
                        "Digite X:",
                        "Digite Y:",
                        "Digite Z:"
                    }, {"0.0", "0.0", "0.0"}, {"number", "number", "number"})
                    
                    if coords then
                        local destino = {
                            x = tonumber(coords[1]),
                            y = tonumber(coords[2]),
                            z = tonumber(coords[3])
                        }
                        caminharAtePosicao(destino.x, destino.y, destino.z, movimentoTipo)
                    end
                    
                elseif opcoes[escolha] == "üßº Caminhar para Posi√ß√£o Salva" then
                    caminharParaPosicaoSalva()
                    
                elseif opcoes[escolha] == "‚ö° Ajustar Velocidade de Carregamento" then
                    ajustarVelocidadeCarregar()
                    
                elseif opcoes[escolha] == "‚è≥ Ajustar Delay do Auto Farm" then
                    ajustarDelayAutoFarm()
                    
                elseif opcoes[escolha] == "‚öôÔ∏è Ajustar Tipo de Movimento" then
                    ajustarTipoMovimento()
                    
                elseif opcoes[escolha] == "‚öôÔ∏è Configurar Subterr√¢neo" then
                    configurarSubterraneo()
                    
                elseif opcoes[escolha] == "üíæ Salvar Posi√ß√£o" then
                    salvarPosicaoAtual("Posi√ß√£o Atual")
                    
                elseif opcoes[escolha] == "üìÅ Carregar Posi√ß√£o Salva" then
                    carregarPosicoesDoArmazenamento()
                    
                elseif opcoes[escolha] == "‚öôÔ∏è Configurar Auto Farm" then
                    salvarPosicoesFarm()
                    
                elseif opcoes[escolha] == "AGR Auto Farm" then
                    autoFarm()
                    
                elseif opcoes[escolha] == "üóëÔ∏è Deletar Posi√ß√£o Salva" then
                    deletarPosicoes()
                    
                elseif opcoes[escolha] == "üõë Parar Caminhada" then
                    pararCaminhada()
                    
                elseif opcoes[escolha] == "‚è±Ô∏è Editar Delay de Posi√ß√£o" then
                    editarDelayPosicao()
                    
                elseif opcoes[escolha] == "‚ö° Configurar Velocidade TP" then
                    configurarVelocidadeTeleporte()
                    
                elseif opcoes[escolha] == "üîÉ Ativar/Desativar Modo Reverso" then
               modoReversoAtivado = not modoReversoAtivado
               if modoReversoAtivado then
                    gg.toast("üîÅ Modo Reverso ATIVADO!")
                  else
                    gg.toast("‚õî Modo Reverso DESATIVADO!")           
               end
                elseif opcoes[escolha] == "‚ùå Sair" then
                    scriptAtivo = false
                    gg.toast("üëã Script finalizado!")
                    return
                end
            end
        end
    end
end
-- Iniciar script
gg.toast("üöÄ GIAN SAMP - RIO RISE\nDesenvolvido por GIAN HENRIQUE\nVers√£o: "..versao)
inicializar()
menuPrincipal()
